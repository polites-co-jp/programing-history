プログラミングのコーディングスタイルの歴史を振り返りながら、確認する。
各スタイルの特徴やメリットデメリットを見ていくことで、保守性の高いプログラミングスタイル獲得のための一助としてほしい。

ただし、すべてメリットデメリットのあるものであり、仕様や環境によって最適解は異なることに留意してほしい。


# 01-非関数化プログラミング

初心者が最初に到達するコーディングスタイル。
関数化することの意味や意義を理解していないプログラマがよく記述する。

## メリット

* 記述量が最も少ない
	* 短期間で作成し、使い捨てになるようなスクリプトに向いている

## デメリット

* 保守性が悪い
	* 仕様が変更されたときの影響範囲が広い
* 「状態」が管理されない
* 変数に格納されている値の一貫性が保存されていない
* コピペコードが多用される傾向がある

## 工夫

特になし

## まとめ

今回作成した中で最も少ない工数で作成できたコードであるが、デメリットで上げたような以降のスタイルで改善される問題を多く内包している。



# 02-関数化プログラミング

01のコードの処理を責務ごとに関数分割した、主にC言語で使用されていたコーディングスタイル。

## メリット

* テストが容易となる
	* テストコードが書ける
	* 関数ごとに動作確認できる
	* 関数ごとに仕様を満たせたことが確認されれば、以後テスト不要となる
* 関数ごとに責務を分割できる
	* 特定の処理のみを実行する関数
	* 手続き的に処理を呼び出す関数
* 関数を再利用できる

## デメリット

* 引数に「すべての変数」を毎回渡す、ないし、取得する必要がある
	* 「状態」が保存されない
	* 冗長的に関数が呼び出される場合がある
* 変数に格納されている値の一貫性が保存されていない
* 関数の名づけに工夫や一貫性が必要になる

## 工夫

main関数などの手続き的に処理を呼び出す関数は、複数の処理を記述する関数は、行う手続きのみを列挙する。（可能な限り制御(if / for)を入れないということになる。）これにより、処理の目次として機能させられる。

## まとめ

01より倍程度のコード量になったが、保守性が向上した。



# 03-オブジェクト指向プログラミング

プログラミング言語の2回目のパラダイムシフトであるオブジェクト指向を取り入れたコーディングスタイル。

## メリット

* 処理と変数を対で管理できる
	* 「状態」を保存することができる
* 認識とデータ・手続きの構造が一致する
* クラスを再利用できる

## デメリット

* 関数のみの場合に比べてテストが難化する
	* 保存されている「状態」が変わるためテストの検証値の一貫性が保証できない
* 変数に格納されている値の一貫性が保存されていない
* 関数・クラスの名づけに工夫や一貫性が必要になる

## 工夫

今回の仕様を満たすために、Schedule・Task・ScheduleManagerの三つのクラスで表現した。
Scheduleに、配列でTaskのインスタンスを持たせることで、スケジュールとタスクの関連性をデータ構造と一致させた。また、種々の処理がSchedule->Taskに対するものとなるため、そのアクセスオブジェクトを１つのオブジェクトで管理するためのクラスであるScheduleManagerを用意した。

## まとめ

データ構造が認識と一致するため、コードだけを見たときの仕様理解が向上する。



# 04-宣言的プログラミング(関数型思考の一部導入)

関数型言語で使われている一部の思想を導入したコーディングスタイル。ここで採用した関数型言語のエッセンスとしては、つぎのことが挙げられる。
* 宣言的記述
* 副作用を持たない関数
* 変数の一貫性の保証

## メリット

* for文を記述しなくなる
	* ループの中でやっていたことが宣言的になる
* テストが容易となる
	* 保存されている「状態」が変わらないためテストの検証値の一貫性が保証できる
* 「状態」を一貫性を持たせた状態で保存することができる
* 認識とデータ・手続きの構造が一致する
* クラスを再利用できる

## デメリット

* 「状態」を一貫性を持たせた状態を維持するためのコストが高い
* 関数・クラスの名づけに工夫や一貫性が必要になる
* 実行速度が最も遅く、使用メモリが最も多い
* コード記述量が最も多い

## 工夫

イテレーションを使用して配列のforをすべて、forEach / map / find / some / filter / everyなどに置き換えて、コードの可視性を向上させた。

値を変更する処理や、特定のクラスインスタンスの内部の値を外に出す処理については、新たなインスタンスを生成して返すようにした。それによって、その値を変更しても取得元のクラスインスタンス内部の値を変更されないことが保証される。

## まとめ

コード量や考えることが増加することと引き換えに保守性が向上する。